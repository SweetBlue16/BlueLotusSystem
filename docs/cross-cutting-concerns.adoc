== Aspectos transversales

Este documento describe la estrategia aplicada en el proyecto BlueLotusSystem para gestionar tres concerns transversales clave: Seguridad, Registro y observabilidad, y Persistencia / Consistencia de datos. Las tácticas y frameworks mencionados ya están integrados en el código del sistema (capas API, Application, Infrastructure), y las decisiones de diseño están alineadas con la arquitectura por capas usada en los módulos BookingService, RoomRepository, PaymentGatewayClient y NotificationService.

=== Concerns utilizados
* Seguridad (autenticación y autorización)
* Registro y observabilidad (logs, trazas, métricas, salud del sistema)
* Persistencia y consistencia de datos (base de datos, transacciones, caché)
* Resiliencia y tolerancia a fallos (reintentos, circuit breaker) — táctica aplicada dentro de observabilidad/resiliencia.

=== Tácticas y frameworks utilizados
* Autenticación: JWT + ASP.NET Core Identity
* Autorización: políticas basadas en claims
* Validación de entradas: FluentValidation
* Gestión de secretos: User Secrets / Azure Key Vault
* Logs: Serilog
* Trazas distribuidas: OpenTelemetry
* Métricas y salud: Prometheus-compatible + Health Checks (/healthz)
* Resiliencia: Polly (retries, circuit-breaker)
* Persistencia: Entity Framework Core (HotelContext)
* Acceso a datos: Repository + Unit of Work
* Caché distribuido: Redis (IDistributedCache), estrategia cache-aside
* Comunicación interna: Domain Events para invalidación de caché y notificaciones.

=== 1. Seguridad

==== Estrategia
* Separar completamente la lógica de seguridad del código de negocio.
* Proteger todas las rutas por defecto y permitir sólo las que deben ser públicas.

==== Tácticas usadas en el proyecto
* Autenticación con JWT + ASP.NET Core Identity.
* Autorización mediante políticas basadas en claims (ej: `"Bookings.Create"`, `"Bookings.ManageAll"`).
* Validación de entradas con FluentValidation.
* Gestión segura de secretos con User Secrets/Azure Key Vault.
* Middleware centralizado para autenticación y autorización.

==== Cómo se aplica aquí
* Controllers reciben únicamente peticiones autenticadas y autorizadas.
* BookingService asume que los permisos ya fueron validados.
* Tests unitarios cubren casos críticos de autorización mediante mocks.

=== 2. Registro y observabilidad

==== Estrategia
* Obtener visibilidad completa del sistema: logs, trazas, métricas y salud.
* Instrumentar puntos clave sin mezclar instrumentación con lógica de negocio.

==== Tácticas usadas en el proyecto
* Logs estructurados con Serilog.
* OpenTelemetry para trazas distribuidas.
* Exportación de métricas para Prometheus.
* Endpoint `/healthz` con Health Checks.
* Polly para reintentos y circuit-breaker con registro de eventos.

==== Cómo se aplica aquí
* Logger inyectado en controllers y servicios.
* PaymentGatewayClient envuelto en spans de OpenTelemetry y políticas de resiliencia.
* `/healthz` reporta estado de BD, Redis y pasarela de pagos.

=== 3. Persistencia y consistencia de datos

==== Estrategia
* Mantener datos correctos incluso ante fallos.
* Usar consistencia fuerte para operaciones críticas (pago + reserva) y eventual para consultas rápidas.

==== Tácticas usadas en el proyecto
* Entity Framework Core como ORM.
* Repository + Unit of Work para centralizar commits/rollbacks.
* Transacciones para operaciones que afectan múltiples entidades.
* Caché distribuido con Redis.
* Cache-aside con expiración corta y invalidación mediante Domain Events.
* Pruebas de integración garantizan consistencia cuando fallan pagos.

==== Cómo se aplica aquí
* BookingService inicia transacción → ejecuta cobro → si éxito hace `Commit()`, si falla → `Rollback()` y compensación.
* AvailabilityQueryHandler usa Redis para responder consultas rápidas.
* Eventos internos invalidan la caché cuando se crea o borra una reserva.


=== Conclusión
La gestión adecuada de los concerns transversales de Seguridad, Registro y observabilidad, y Persistencia / Consistencia de datos es fundamental para el éxito del sistema BlueLotusSystem. Al aplicar estrategias y tácticas específicas para cada uno de estos aspectos, se garantiza que el sistema no solo cumple con los requisitos funcionales, sino que también ofrece una experiencia segura, confiable y eficiente para sus usuarios. La separación clara de responsabilidades y la integración de frameworks probados permiten mantener un código limpio y fácil de mantener, facilitando futuras ampliaciones y mejoras del sistema.

